(* -*- tuareg -*- *)
(* Test file *)

let pi = builtin "pi"
let sin = builtin "sin"
let cos = builtin "cos"
let random = builtin "random"
let print = builtin "print"
(* let emit = builtin "emit" *)
let run = builtin "run"
let play = builtin "play"

let id(x) = x

(** No action. *)
let nact() = ()

let ignore (x) = ()

let prev(init, x) =
  (* TODO: proper type generalization *)
  let init = (init : float) in
  let y = ref init in
  let ans = !y in
  y := x;
  ans

let on(b,f) =
  (* TODO: use usual prev *)
  let prev(x) =
    let x' = ref false in
    let ans = !x' in
    x' := x;
    ans
  in
  let b' = prev(b) in
  if (b && not b') then f()

(* let prevn(n,x) = *)
  (* let n = (n : static int) in *)
  (* for i = 0 to n-1 do *)
    (* let x = prev(0.,x) in *)
    (* () *)
  (* done; *)
  (* x *)

let array =
  struct
    let empty = []

    let create = builtin "array_create"

    let length = builtin "array_length"

    let iter(f,a) =
      for i = 0 to length(a)-1 do
        f(a[i])
      done

    let hd(a) = a[0]

    let tl = builtin "array_tail"

    let play = builtin "array_play"
  end

(** Dummy implementation of events. *)
let event =
  struct
    let create (x) =
      ref (event=false,value=x)

    (* let emit (e,x) = *)
      (* e := (event=true,value=x) *)

    let handle (e,f) =
      if (!e).event then f((!e).value);
      e := (event=false, value=(!e).value)
  end

let integrator =
  struct
    let euler(reset=id,phase=0.,f') =
      let x = ref phase in
      let ans = !x in
      x := !x + dt * f';
      x := reset(!x);
      ans
  end

let time =
  struct
    let now() = integrator.euler(1.)

    let distort(f,s) =
      let dt = f(dt) in
      s()

    let accelerate(freq,phase=0.,x) = distort(fun (t) -> freq*t+phase, x)

    (* let seq (f,a) = *)
      (* let t = now () in *)
      (* let t0 = ref 0. in *)
  end

let osc =
  struct
    let sine(freq,phase=0.) = sin(2 * pi * integrator.euler(freq,phase=))

    let saw(freq,phase=0.) =
      let reset(x) = if x >= 2 then x-2 else x in
      let x = integrator.euler(freq,phase=,reset=) in
      x - 1

    let square(freq,phase=0.) =
      let x = saw(freq,phase=) in
      if x >= 0.5 then -1 else 1.

    let triangle(freq,phase=0.) =
      let x = saw(freq,phase=0.25) in
      if x <= 0. then 2*x+1 else -2*x+1

    let random() =
      random(2.)-1
  end

let frequency =
  struct
    let vibrato(freq,amp,x) =
      (1+amp*osc.sine(freq))*x
  end

let envelope =
  struct
    let gain(n,x) = n*x

    let activate(x) =
      let active = ref false in
      let x = if !active then x else 0. in
      (x, activate=fun()->active:=true)

    (** The functions should be valid between 0 and 1 and return something
        between 0 (at begining) and 1 (at end), dfun and rfun being read
        backwards. *)
    let adsr(a,afun=id,d,dfun=id,s,r,rfun=id,on_die=fun()->(),x) =
      let t = time.now() in
      let state = ref 0 in
      let rtime = ref (-1.) in
      let die () =
        state := 4;
        on_die()
      in
      if !state == 0 then (if t >= a then state := 1)
      else if !state == 1 then (if t >= a+d then if s == 0. then die() else state := 2);
      let n =
        (* Attack. *)
        if !state == 0 then afun(t/a)
        (* Decay. *)
        else if !state == 1 then dfun(1-(t-a)/d)*(1-s)+s
        (* Released. *)
        else if !state == 4 then 0.
        (* Release. *)
        else if !rtime >= 0 then
          if t-!rtime >= r then (die(); 0.)
          else rfun(1-(t-!rtime)/r)*s
        (* Sustain. *)
        else s
      in
      (n*x, release=fun()->rtime := t)

    let ad(a,afun=id,d,dfun=id,on_die=fun()->(),x) = adsr(a,afun=,d,dfun=,0,0,on_die=,x)

    let tremolo(amplitude,freq,x) =
      (1+amplitude*osc.sine(freq))*x
  end

let filter =
  struct
    let first_order =
    struct
      let low_pass(freq,x) =
        let rc = 1/(2*pi*freq) in
        let a = dt/(rc+dt) in
        let rec y =
          let y' = prev(0.,y) in
          y'+a*(x-y')
        in
        y
      let lp = low_pass

      let high_pass(freq,x) =
        let rc = 1/(2*pi*freq) in
        let a = rc/(rc+dt) in
        let rec y =
          a*(prev(0.,y)+x-prev(0.,x))
        in
        y
      let hp = high_pass
    end
    let fo = first_order

    let iir (a,b,x) =
      (* let la = array.length a in *)
      (* for i = 0 to la - 1 do *)
        (* let  *)
      (* done *)
      ()

    let fir (a,x) = iir(a,[],x)

    (** See http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt *)
    let biquad =
    struct
      let high_pass(freq,q,x) =
        let w0 = 2*pi*freq*dt in
        let alpha = sin(w0)/(2*q) in
        let a = [1+alpha,-2*cos(w0),1-alpha] in
        let b = [(1+cos(w0))/2,-(1+cos(w0)),(1+cos(w0))/2] in
        ()
    end
  end

type instrument = ()->(float,freq:(float)->())

let instrument =
  struct
    let make (freq=ignore,gain=fun(x)->(),off=fun()->(),activate=fun()->(),is_active=fun()->true,f) =
      (
        freq=,
        gain=,
        off=,
        activate=,
        is_active=,
        f
      )

    let adsr(a,d,s,r,x) =
      let f = ref 440. in
      let x = envelope.activate(x(!f)) in
      let g = ref 1. in
      let act = ref false in
      let on_die () = act := false in
      let x = envelope.adsr(a,d,s,r,on_die=,x.) in
      (
        !g*x.,
        freq = fun (x) -> f := x,
        gain = fun (x) -> g := x,
        activate = fun (x) -> x.activate(); act := true,
        is_active = fun () -> !act
      )

    let play(s) =
      let player() =
        let dt = 1./44100. in
        let s = (s : instrument) in
        let prog = emit(s) in
        let state = prog.alloc() in
        let run() = prog.run(state) in
        let freq(f) = prog.freq(state,f) in
        let buflen = 1024 in
        let buf = array.create(buflen,0.) in
        let t = ref 0. in
        let f = ref 440. in
        for i = 0 to buflen-1 do
          buf[i] := run();
          freq(!t*440);
          t := !t + dt
          (* if duration >= 0 then on(!t >= duration, release) *)
        done;
        array.play(buf)
      in
      run(player)
  end

(* let () = *)
  (* let s (freq) = osc.sine(freq) in *)
  (* let i () = instrument.adsr(0.5,0.4,0.8,1,s) in *)
  (* play(i) *)

let s() = osc.sine(440,phase=0.777)
let s() = time.accelerate(440+60*time.accelerate(10*time.now,fun()->osc.sine(1)),fun()->osc.saw(1.))
let s() = (1+osc.sine(4)*0.1)*(envelope.adsr(0.5,0.4,0.7,1,fun()->osc.triangle(440))).
(* let s() = *)
  (* array.iter (print,[1,2,3]); *)
  (* 0. *)
(* let s() = osc.saw(freq=440*envelope.tremolo(0.1,4,1)) *)
(* let s() = filter.first_order.low_pass(1000+1000*osc.sine(freq=0.5),s) *)
(* let s() = osc.sine(freq=440) *)

(* let s()= *)
  (* let prev(x) = *)
    (* let r = ref 0. in *)
    (* let y = !r in *)
    (* r := x; *)
    (* y *)
  (* in *)
  (* let rec xrec = prev(xrec) in *)
  (* xrec *)

(* let s() = instrument.adsr(0.8,0.2,0.8,0.3,osc.sine) *)
(* let s() = envelope.adsr(0.01,0.04,0.,1,osc.random)+s *)
let s() = envelope.ad(0.01,2,dfun=fun(x)->x*x,on_die=fun ()->print("DIED!\n"),osc.saw(frequency.vibrato(4,0.01,440))+osc.random*0.1)

(* let () = play (s) *)

(* let s() = osc.sine(freq=440,phase=12) *)
(* let () = play_song(s) *)


(* let s() = *)
  (* let t = ref 0. in *)
  (* let ans = sin(2*pi*!t) in *)
  (* t := !t + 440 * dt; *)
  (* ans *)

let play(duration=-1,s)=
  let player() =
    let dt = 1./44100. in
    let s = (s:()->(float, release:()->())) in
    let s() =
      let s = s() in
      (s with die=fun()->print("DIE!"))
    in
    let prog = emit(s) in
    let state = prog.alloc() in
    let run() = prog.run(state) in
    let release() = prog.release(state) in
    let buflen = 1024 in
    let buf = array.create(buflen,0.) in
    let t = ref 0. in
    for i = 0 to buflen-1 do
      buf[i] := run();
      t := !t + dt;
      if duration >= 0 then on(!t >= duration, release)
    done;
    array.play(buf)
  in
  run(player)

let () = play(s)

(* let s() = (1+osc.sine(4)*0.1)*envelope.adsr(0.5,0.4,0.7,1,osc.triangle(440)) *)
let s() = osc.sine(440)
let s() =
  let a = ref 1. in
  (!a*s(),release=fun () -> print("RELEASE!\n");a:=0)

(* let () = *)
  (* play(release=s.release,duration=1.,s) *)
  (* play(duration=1,s) *)
